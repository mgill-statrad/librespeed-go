
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>librespeed_exporter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">librespeed_exporter/main.go (40.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "archive/zip"
        "bytes"
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/golang/snappy"
        "github.com/prometheus/prometheus/prompb"
)

type CommandRunner interface {
        Run(name string, args ...string) ([]byte, error)
}

type DefaultRunner struct{}

func (r *DefaultRunner) Run(name string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        cmd := exec.Command(name, args...)
        var out bytes.Buffer
        var stderr bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("librespeed-cli error output: %s", stderr.String())
                return nil, fmt.Errorf("command failed: %v", err)
        }</span>
        <span class="cov8" title="1">return out.Bytes(), nil</span>
}

type ServerInfo struct {
        ID  int    `json:"id"`
        URL string `json:"url"`
}

type LibrespeedResult struct {
        Download float64    `json:"download"`
        Upload   float64    `json:"upload"`
        Ping     float64    `json:"ping"`
        Jitter   float64    `json:"jitter"`
        Server   ServerInfo `json:"server"`
}

func ensureLibrespeedCLI() (string, error) <span class="cov0" title="0">{
        log.Println("Checking for librespeed-cli...")
        
        exePath, err := exec.LookPath("librespeed-cli.exe")
        if err == nil </span><span class="cov0" title="0">{
                log.Printf("Found librespeed-cli at: %s", exePath)
                return exePath, nil
        }</span>

        <span class="cov0" title="0">installDir := `C:\librespeed-cli`
        exePath = filepath.Join(installDir, "librespeed-cli.exe")

        if _, err := os.Stat(exePath); err == nil </span><span class="cov0" title="0">{
                log.Printf("Found librespeed-cli in install directory: %s", installDir)
                os.Setenv("PATH", installDir+";"+os.Getenv("PATH"))
                return exePath, nil
        }</span>

        <span class="cov0" title="0">log.Println("librespeed-cli not found. Downloading...")

        err = os.MkdirAll(installDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create install directory: %v", err)
        }</span>

        <span class="cov0" title="0">zipURL := "https://github.com/librespeed/speedtest-cli/releases/download/v1.0.12/librespeed-cli_1.0.12_windows_amd64.zip"
        
        // Create HTTP client with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        req, err := http.NewRequestWithContext(ctx, "GET", zipURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create HTTP request: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Downloading from: %s", zipURL)
        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to download ZIP: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("download failed with status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">log.Printf("Download successful, status: %s", resp.Status)

        zipPath := filepath.Join(installDir, "librespeed-cli.zip")
        out, err := os.Create(zipPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create ZIP file: %v", err)
        }</span>
        <span class="cov0" title="0">defer out.Close()

        _, err = io.Copy(out, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to save ZIP file: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Extracting librespeed-cli...")

        // Extract the ZIP
        r, err := zip.OpenReader(zipPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open ZIP: %v", err)
        }</span>
        <span class="cov0" title="0">defer r.Close()

        found := false
        for _, f := range r.File </span><span class="cov0" title="0">{
                if strings.EqualFold(f.Name, "librespeed-cli.exe") </span><span class="cov0" title="0">{
                        rc, err := f.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to open file in ZIP: %v", err)
                        }</span>
                        <span class="cov0" title="0">defer rc.Close()

                        outExe, err := os.Create(exePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to create EXE file: %v", err)
                        }</span>
                        <span class="cov0" title="0">defer outExe.Close()

                        _, err = io.Copy(outExe, rc)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to extract EXE: %v", err)
                        }</span>
                        <span class="cov0" title="0">found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return "", fmt.Errorf("librespeed-cli.exe not found in downloaded ZIP file")
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully installed librespeed-cli to: %s", exePath)
        os.Setenv("PATH", installDir+";"+os.Getenv("PATH"))
        return exePath, nil</span>
}

func runLibrespeed(runner CommandRunner, cliPath, localJSONPath string, serverID *int) (*LibrespeedResult, error) <span class="cov8" title="1">{
        log.Println("Running librespeed-cli...")
        start := time.Now()

        args := []string{"--telemetry-level", "basic", "--json", "--verbose"}

        if serverID != nil &amp;&amp; localJSONPath != "" </span><span class="cov8" title="1">{
                args = append(args, "--local-json", localJSONPath, "--server", fmt.Sprintf("%d", *serverID))
        }</span> else<span class="cov8" title="1"> if localJSONPath != "" </span><span class="cov8" title="1">{
                args = append(args, "--local-json", localJSONPath)
        }</span>
        
        <span class="cov8" title="1">log.Printf("Running command: %s %s", cliPath, strings.Join(args, " "))
        output, err := runner.Run(cliPath, args...)
        duration := time.Since(start)
        
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("librespeed-cli failed after %v: %v", duration, err)
                return nil, fmt.Errorf("failed to run librespeed-cli: %v", err)
        }</span>
        
        <span class="cov8" title="1">log.Printf("librespeed-cli completed in %v", duration)
        log.Printf("librespeed-cli raw output: %s", string(output))

        var results []LibrespeedResult
        if err := json.Unmarshal(output, &amp;results); err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to parse JSON output: %v", err)
                return nil, fmt.Errorf("failed to parse JSON: %v", err)
        }</span>
        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov8" title="1">{
                log.Println("No results returned from librespeed-cli")
                return nil, fmt.Errorf("no results returned from librespeed-cli")
        }</span>
        
        <span class="cov8" title="1">result := &amp;results[0]
        log.Printf("Speed test results - Download: %.2f Mbps, Upload: %.2f Mbps, Ping: %.2f ms, Jitter: %.2f ms", 
                result.Download, result.Upload, result.Ping, result.Jitter)
                
        return result, nil</span>
}

func createTimeSeries(metric string, value float64, ts int64, serverURL, instance string) *prompb.TimeSeries <span class="cov8" title="1">{
        return &amp;prompb.TimeSeries{
                Labels: []prompb.Label{
                        {Name: "__name__", Value: metric},
                        {Name: "server_url", Value: serverURL},
                        {Name: "instance", Value: instance},
                },
                Samples: []prompb.Sample{
                        {Value: value, Timestamp: ts},
                },
        }
}</span>

func getLabelValue(labels []prompb.Label, name string) string <span class="cov8" title="1">{
        for _, label := range labels </span><span class="cov8" title="1">{
                if label.Name == name </span><span class="cov8" title="1">{
                        return label.Value
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func sendToRemoteWrite(url, username, password string, series []*prompb.TimeSeries) error <span class="cov8" title="1">{
        if len(series) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no time series data to send")
        }</span>
        
        <span class="cov8" title="1">log.Printf("Preparing to send %d metrics to remote write endpoint", len(series))
        
        var tsList []prompb.TimeSeries
        for _, ts := range series </span><span class="cov8" title="1">{
                log.Printf("Sending metric: %s | Server: %s | Instance: %s | Value: %.2f | Timestamp: %d",
                        getLabelValue(ts.Labels, "__name__"),
                        getLabelValue(ts.Labels, "server_url"),
                        getLabelValue(ts.Labels, "instance"),
                        ts.Samples[0].Value,
                        ts.Samples[0].Timestamp,
                )
                tsList = append(tsList, *ts)
        }</span>

        <span class="cov8" title="1">req := &amp;prompb.WriteRequest{
                Timeseries: tsList,
        }

        data, err := req.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal protobuf: %v", err)
        }</span>

        <span class="cov8" title="1">compressed := snappy.Encode(nil, data)
        log.Printf("Payload size: %d bytes (compressed: %d bytes)", len(data), len(compressed))

        reqBody := bytes.NewReader(compressed)
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        httpReq, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create HTTP request: %v", err)
        }</span>

        <span class="cov8" title="1">httpReq.Header.Set("Content-Encoding", "snappy")
        httpReq.Header.Set("Content-Type", "application/x-protobuf")
        httpReq.Header.Set("X-Prometheus-Remote-Write-Version", "0.1.0")
        httpReq.SetBasicAuth(username, password)

        client := &amp;http.Client{Timeout: 30 * time.Second}
        start := time.Now()
        resp, err := client.Do(httpReq)
        duration := time.Since(start)
        
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP request failed after %v: %v", duration, err)
                return fmt.Errorf("failed to send HTTP request: %v", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        log.Printf("Received response: %s (duration: %v)", resp.Status, duration)

        if resp.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                log.Printf("Remote write failed with response body: %s", string(body))
                return fmt.Errorf("remote_write failed: %s - %s", resp.Status, string(body))
        }</span>

        <span class="cov8" title="1">log.Println("Metrics sent successfully to remote write endpoint")
        return nil</span>
}

func validateLogFilePath(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("log file path cannot be empty")
        }</span>
        
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if stat, err := os.Stat(dir); os.IsNotExist(err) || !stat.IsDir() </span><span class="cov8" title="1">{
                return fmt.Errorf("log file directory does not exist: %s", dir)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func main() <span class="cov0" title="0">{
        logFilePath := flag.String("logfile", "librespeed_exporter.log", "Path to the log file")
        url := flag.String("url", "", "Grafana Cloud remote_write URL")
        username := flag.String("username", "", "Grafana Cloud instance ID")
        password := flag.String("password", "", "Grafana Cloud API key")
        localJSONPath := flag.String("local-json", "", "Path to JSON file with server list")
        serverID := flag.Int("server-id", 1, "ID of the server to use from the JSON list")
        flag.Parse()

        log.Println("Starting librespeed exporter...")
        log.Printf("Version: librespeed-go (production-ready)")
        log.Printf("Log file: %s", *logFilePath)

        if err := validateLogFilePath(*logFilePath); err != nil </span><span class="cov0" title="0">{
                log.Printf("Invalid log file path: %v", err)
                fmt.Fprintf(os.Stderr, "Invalid log file path: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logFile, err := os.OpenFile(*logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to open log file: %v", err)
                fmt.Fprintf(os.Stderr, "Failed to open log file: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := logFile.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing log file: %v", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">log.SetOutput(io.MultiWriter(os.Stdout, logFile))
        log.SetFlags(log.LstdFlags | log.Lmicroseconds)

        // Validate required parameters
        if *url == "" || *username == "" || *password == "" </span><span class="cov0" title="0">{
                log.Println("ERROR: All flags --url, --username, and --password are required.")
                fmt.Fprintf(os.Stderr, "ERROR: Missing required parameters. Use --help for usage information.\n")
                os.Exit(1)
        }</span>

        // Log configuration (without sensitive data)
        <span class="cov0" title="0">log.Printf("Configuration - URL: %s, Username: %s, Local JSON: %s, Server ID: %d", 
                *url, *username, *localJSONPath, *serverID)

        start := time.Now()
        
        cliPath, err := ensureLibrespeedCLI()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: Failed to ensure librespeed-cli: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">result, err := runLibrespeed(&amp;DefaultRunner{}, cliPath, *localJSONPath, serverID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: Failed to run librespeed test: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARNING: Failed to get hostname, using 'unknown': %v", err)
                hostname = "unknown"
        }</span>
        
        <span class="cov0" title="0">log.Printf("Instance hostname: %s", hostname)

        now := time.Now().UnixMilli()
        series := []*prompb.TimeSeries{
                createTimeSeries("librespeed_download_mbps", result.Download, now, result.Server.URL, hostname),
                createTimeSeries("librespeed_upload_mbps", result.Upload, now, result.Server.URL, hostname),
                createTimeSeries("librespeed_ping_ms", result.Ping, now, result.Server.URL, hostname),
                createTimeSeries("librespeed_jitter_ms", result.Jitter, now, result.Server.URL, hostname),
        }

        if err := sendToRemoteWrite(*url, *username, *password, series); err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: Failed to send metrics: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">totalDuration := time.Since(start)
        log.Printf("SUCCESS: Librespeed exporter completed successfully in %v", totalDuration)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
